# Esqueleto completo Pergamino App (Expo SDK 53, Android/Web)

---

## src/navigation/AppNavigator.js

/**
 * AppNavigator: Stack principal con AuthStack, MainTabs, Onboarding, Settings, Campaigns, Customers, Reports.
 * Mockeable en tests: importa NavigationContainer y los stacks.
 */
import React, { useContext } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { PaperProvider } from 'react-native-paper';
import { ThemeContext } from '../context/ThemeContext';
import { RequireAuth, RequireRole } from './RouteGuards';

import LoginScreen from '../screens/LoginScreen';
import RegisterScreen from '../screens/RegisterScreen';
import AdminDashboard from '../screens/AdminDashboard';
import WaiterDashboard from '../screens/WaiterDashboard';
import CustomerDashboard from '../screens/CustomerDashboard';
import Onboarding from '../screens/Onboarding';
import Settings from '../screens/Settings';
import Campaigns from '../screens/Campaigns';
import Customers from '../screens/Customers';
import Reports from '../screens/Reports';
import Landing from '../screens/marketing/Landing';

const Stack = createNativeStackNavigator();
const Tab = createBottomTabNavigator();

function MainTabs() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Admin" component={RequireRole(['admin'], AdminDashboard)} options={{ tabBarLabel: 'Admin', testID: 'admin-dashboard' }} />
      <Tab.Screen name="Waiter" component={RequireRole(['waiter'], WaiterDashboard)} options={{ tabBarLabel: 'Mesero', testID: 'waiter-dashboard' }} />
      <Tab.Screen name="Customer" component={RequireRole(['customer'], CustomerDashboard)} options={{ tabBarLabel: 'Cliente', testID: 'customer-dashboard' }} />
    </Tab.Navigator>
  );
}

export default function AppNavigator() {
  const { theme } = useContext(ThemeContext);
  return (
    <SafeAreaProvider>
      <PaperProvider theme={theme}>
        <NavigationContainer>
          <Stack.Navigator initialRouteName="Landing">
            <Stack.Screen name="Landing" component={Landing} options={{ headerShown: false }} />
            <Stack.Screen name="Onboarding" component={Onboarding} />
            <Stack.Screen name="Login" component={LoginScreen} options={{ testID: 'login-screen' }} />
            <Stack.Screen name="Register" component={RegisterScreen} />
            <Stack.Screen name="MainTabs" component={RequireAuth(MainTabs)} options={{ headerShown: false }} />
            <Stack.Screen name="Settings" component={RequireAuth(Settings)} />
            <Stack.Screen name="Campaigns" component={RequireAuth(Campaigns)} />
            <Stack.Screen name="Customers" component={RequireAuth(Customers)} />
            <Stack.Screen name="Reports" component={RequireAuth(Reports)} />
          </Stack.Navigator>
        </NavigationContainer>
      </PaperProvider>
    </SafeAreaProvider>
  );
}

---

## src/navigation/RouteGuards.js

/**
 * RouteGuards: RequireAuth y RequireRole para proteger rutas.
 * Mockeable en tests: puedes simular user/userRole en AuthContext.
 */
import React, { useContext } from 'react';
import { View, Text, Button } from 'react-native';
import { AuthContext } from '../context/AuthContext';

export function RequireAuth(Component) {
  return function Wrapper(props) {
    const { isAuthenticated, loading, logout } = useContext(AuthContext);
    if (loading) return <Text>Loading...</Text>;
    if (!isAuthenticated) {
      return (
        <View>
          <Text>Acceso denegado: debes iniciar sesión.</Text>
          <Button title="Ir a Login" onPress={() => props.navigation.replace('Login')} />
        </View>
      );
    }
    return <Component {...props} />;
  };
}

export function RequireRole(roles, Component) {
  return function Wrapper(props) {
    const { userRole, isAuthenticated, loading, logout } = useContext(AuthContext);
    if (loading) return <Text>Loading...</Text>;
    if (!isAuthenticated) {
      return (
        <View>
          <Text>Acceso denegado: debes iniciar sesión.</Text>
          <Button title="Ir a Login" onPress={() => props.navigation.replace('Login')} />
        </View>
      );
    }
    if (!roles.includes(userRole)) {
      return (
        <View>
          <Text>Acceso denegado: rol insuficiente.</Text>
          <Button title="Cerrar sesión" onPress={logout} />
        </View>
      );
    }
    return <Component {...props} />;
  };
}

---

## src/context/AuthContext.js

/**
 * AuthContext: provee user, isAuthenticated, userRole, login, register, logout.
 * Mockeable en tests: puedes envolver cualquier componente con AuthProvider.
 */
import React, { createContext, useState, useEffect } from 'react';
import { app, auth, db, enableEmulatorsIfNeeded } from '../services/firebaseClient';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from 'firebase/auth';
import { doc, getDoc } from 'firebase/firestore';

export const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [userRole, setUserRole] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    enableEmulatorsIfNeeded({ auth, db });
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      setUser(firebaseUser);
      if (firebaseUser) {
        // Obtiene el rol desde Firestore
        const ref = doc(db, 'roles', firebaseUser.uid);
        const snap = await getDoc(ref);
        setUserRole(snap.exists() ? snap.data().role : null);
      } else {
        setUserRole(null);
      }
      setLoading(false);
    });
    return () => unsubscribe();
  }, []);

  const login = async (email, password) => {
    setLoading(true);
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } finally {
      setLoading(false);
    }
  };

  const register = async (email, password) => {
    setLoading(true);
    try {
      await createUserWithEmailAndPassword(auth, email, password);
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    setLoading(true);
    await signOut(auth);
    setLoading(false);
  };

  return (
    <AuthContext.Provider value={{ user, isAuthenticated: !!user, userRole, loading, login, register, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

---

## src/context/ThemeContext.js

/**
 * ThemeContext: provee tema claro/oscuro y useTheme().
 * Mockeable en tests: puedes envolver cualquier componente con ThemeProvider.
 */
import React, { createContext, useState, useContext } from 'react';
import { MD3LightTheme, MD3DarkTheme } from 'react-native-paper';

export const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [isDark, setIsDark] = useState(false);
  const theme = isDark ? MD3DarkTheme : MD3LightTheme;
  const toggleTheme = () => setIsDark((d) => !d);
  return (
    <ThemeContext.Provider value={{ theme, isDark, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}

---

## src/services/firebaseClient.js

/**
 * Inicializa Firebase usando variables EXPO_PUBLIC_* desde .env.local.
 * Exporta app, auth, db, useEmulators, enableEmulatorsIfNeeded.
 * Mockeable en tests: puedes mockear los métodos y objetos.
 */
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator } from 'firebase/firestore';
import { initializeAuth, getAuth, connectAuthEmulator, getReactNativePersistence } from 'firebase/auth';
import AsyncStorage from '@react-native-async-storage/async-storage';

const firebaseConfig = {
  apiKey: process.env.EXPO_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.EXPO_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.EXPO_PUBLIC_FIREBASE_BUCKET,
  messagingSenderId: process.env.EXPO_PUBLIC_FIREBASE_SENDER_ID,
  appId: process.env.EXPO_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.EXPO_PUBLIC_FIREBASE_MEASUREMENT_ID,
};

export const app = getApps().length ? getApp() : initializeApp(firebaseConfig);

let auth;
try {
  auth = initializeAuth(app, { persistence: getReactNativePersistence(AsyncStorage) });
} catch (e) {
  auth = getAuth(app);
}
export { auth };

export const db = getFirestore(app);

export const useEmulators = (process.env.EXPO_PUBLIC_USE_EMULATORS ?? 'false') === 'true';

export function enableEmulatorsIfNeeded({ auth, db }) {
  if (!useEmulators) return;
  const ah = process.env.EXPO_PUBLIC_FIREBASE_AUTH_EMULATOR_HOST || '127.0.0.1';
  const ap = parseInt(process.env.EXPO_PUBLIC_FIREBASE_AUTH_EMULATOR_PORT || '9100', 10);
  const fh = process.env.EXPO_PUBLIC_FIRESTORE_EMULATOR_HOST || '127.0.0.1';
  const fp = parseInt(process.env.EXPO_PUBLIC_FIRESTORE_EMULATOR_PORT || '8081', 10);
  try { connectAuthEmulator(auth, `http://${ah}:${ap}`, { disableWarnings: true }); } catch {}
  try { connectFirestoreEmulator(db, fh, fp); } catch {}
}

---

## src/services/notificationsService.js

/**
 * notificationsService: expo-notifications, sendLocalNotification, geopush simulado en dev.
 * Mockeable en tests: mock expo-notifications.
 */
import * as Notifications from 'expo-notifications';
import * as Location from 'expo-location';

export async function registerForPushNotificationsAsync() {
  const { status } = await Notifications.requestPermissionsAsync();
  if (status !== 'granted') return null;
  const tokenData = await Notifications.getExpoPushTokenAsync();
  return tokenData.data;
}

export async function sendLocalNotification({ title, body, data }) {
  await Notifications.scheduleNotificationAsync({
    content: { title, body, data },
    trigger: null,
  });
}

// Geopush simulado en dev
export async function simulateGeoPushIfNear({ useEmulators }) {
  if (!useEmulators) return;
  const { status } = await Location.requestForegroundPermissionsAsync();
  if (status !== 'granted') return;
  const pos = await Location.getCurrentPositionAsync({});
  // Simula “cercanía” si lat/lng dentro de rango (mock en tests)
  if (pos && pos.coords.latitude && pos.coords.longitude) {
    await sendLocalNotification({
      title: '¡Estás cerca!',
      body: '2×1 hoy en tu restaurante favorito.',
      data: { type: 'geo-push' },
    });
  }
}

---

## src/services/locationService.js

/**
 * locationService: expo-location helpers.
 * Mockeable en tests: mock expo-location.
 */
import * as Location from 'expo-location';

export async function requestPermissions() {
  return await Location.requestForegroundPermissionsAsync();
}

export async function getCurrentPosition() {
  return await Location.getCurrentPositionAsync({});
}

export function watchPosition(cb) {
  return Location.watchPositionAsync({ accuracy: Location.Accuracy.High }, cb);
}

---

## src/services/automationService.js

/**
 * automationService: motor de automatizaciones por tiempo/evento.
 * Mockeable en tests: mock timers y Firestore.
 */
import { db } from './firebaseClient';
import { collection, getDocs } from 'firebase/firestore';
import { sendLocalNotification } from './notificationsService';

let jobInterval = null;

export function startAutomationJobs({ useEmulators }) {
  if (!useEmulators) return;
  stopAutomationJobs();
  jobInterval = setInterval(async () => {
    const automations = await getDocs(collection(db, 'Automations'));
    automations.forEach(async (docSnap) => {
      const automation = docSnap.data();
      if (automation.active && automation.type === 'scheduled') {
        await sendLocalNotification({
          title: automation.title || 'Automatización',
          body: automation.body || 'Evento programado.',
          data: { type: 'automation', id: docSnap.id },
        });
      }
    });
  }, 60000); // cada 60s en dev
}

export function stopAutomationJobs() {
  if (jobInterval) clearInterval(jobInterval);
}

---

## src/services/customersService.js

/**
 * customersService: CRUD clientes, puntos, tags, exportación CSV.
 * Mockeable en tests: mock Firestore y FileSystem.
 */
import { db } from './firebaseClient';
import { collection, getDocs, doc, setDoc, updateDoc, deleteDoc } from 'firebase/firestore';
import * as FileSystem from 'expo-file-system';

export async function getCustomers() {
  const snap = await getDocs(collection(db, 'Customers'));
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}

export async function addCustomer(data) {
  const ref = doc(collection(db, 'Customers'));
  await setDoc(ref, data);
  return ref.id;
}

export async function updateCustomer(id, data) {
  const ref = doc(db, 'Customers', id);
  await updateDoc(ref, data);
}

export async function deleteCustomer(id) {
  const ref = doc(db, 'Customers', id);
  await deleteDoc(ref);
}

export async function exportCSV() {
  const customers = await getCustomers();
  const csv = [
    ['id', 'name', 'email', 'points', 'tags'],
    ...customers.map((c) => [c.id, c.name, c.email, c.points, c.tags?.join('|') || '']),
  ].map((row) => row.join(',')).join('\n');
  // En nativo: FileSystem
  const fileUri = FileSystem.documentDirectory + 'clientes.csv';
  await FileSystem.writeAsStringAsync(fileUri, csv);
  return fileUri;
}

---

## src/services/campaignsService.js

/**
 * campaignsService: CRUD campañas, push/geo-push, audiencias, scheduling.
 * Mockeable en tests: mock Firestore.
 */
import { db } from './firebaseClient';
import { collection, getDocs, doc, setDoc, updateDoc, deleteDoc } from 'firebase/firestore';

export async function getCampaigns() {
  const snap = await getDocs(collection(db, 'Campaigns'));
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}

export async function addCampaign(data) {
  const ref = doc(collection(db, 'Campaigns'));
  await setDoc(ref, data);
  return ref.id;
}

export async function updateCampaign(id, data) {
  const ref = doc(db, 'Campaigns', id);
  await updateDoc(ref, data);
}

export async function deleteCampaign(id) {
  const ref = doc(db, 'Campaigns', id);
  await deleteDoc(ref);
}

export async function createDemoCampaign() {
  return await addCampaign({
    name: 'Demo Campaña',
    type: 'push',
    active: true,
    audience: 'all',
    scheduled: false,
    createdAt: Date.now(),
  });
}

---

# Comandos para preparar y validar

echo "EXPO_PUBLIC_FIREBASE_PROJECT_ID=codigos-pergamino`nEXPO_PUBLIC_USE_EMULATORS=true`nEXPO_PUBLIC_FIREBASE_AUTH_EMULATOR_PORT=9100`nEXPO_PUBLIC_FIRESTORE_EMULATOR_PORT=8081`nEXPO_PUBLIC_FIREBASE_API_KEY=TU_API_KEY`nEXPO_PUBLIC_FIREBASE_APP_ID=TU_APP_ID`nEXPO_PUBLIC_FIREBASE_SENDER_ID=TU_SENDER_ID`nEXPO_PUBLIC_FIREBASE_MEASUREMENT_ID=TU_MEASUREMENT_ID`nEXPO_PUBLIC_FIREBASE_AUTH_DOMAIN=TU_AUTH_DOMAIN`nEXPO_PUBLIC_FIREBASE_BUCKET=TU_BUCKET" > .env.local

npm run emulators
npm run start:dev
npm run local+tests
npm run test:smoke && npm run test:unit && npm run test:integration

---

# Todos los archivos incluyen comentarios para testing/mocks y cumplen con el prompt. Si necesitas el contenido de los archivos de UI, marketing, onboarding o tests, indícalo y los agrego aquí.
